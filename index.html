<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,viewport-fit=cover">
<title>WebXR AR - Medi√ß√£o de Dist√¢ncia</title>
<style>
 html,body{height:100%;margin:0;font-family:Arial,Helvetica,sans-serif;background:#111;color:#ddd}
 #info, #distance-panel, #coordinates-panel {
  position:fixed;
  left:10px;
  z-index:2;
  background:rgba(0,0,0,0.5);
  padding:10px;
  border-radius:8px;
  max-height: calc(100% - 20px);
  overflow-y: auto;
 }
 #info { top: 10px; }
 #coordinates-panel { top: 100px; } /* üí° Novo painel */
 #distance-panel { top: 300px; }
 canvas{display:block}
</style>
</head>
<body>
<div id="info">
 <strong>WebXR AR - Medi√ß√£o de Dist√¢ncia</strong><br>
 Toque para colocar cubos e ver a dist√¢ncia entre eles.
</div>

<div id="coordinates-panel">
 <h3>Coordenadas Salvas:</h3>
</div>

<div id="distance-panel">
 <h3>Dist√¢ncias:</h3>
</div>

<script type="module">
 import * as THREE from 'https://unpkg.com/three@0.148.0/build/three.module.js';
 import { ARButton } from 'https://unpkg.com/three@0.148.0/examples/jsm/webxr/ARButton.js';

 let camera, scene, renderer;
 let controller;
 let reticle;
 let anchoredObjects = [];
 let hitTestSource = null;
 let localReferenceSpace = null;
 let hitTestResult = null;

 let blockCounter = 0;
 const distancePanel = document.getElementById('distance-panel');
 const coordinatesPanel = document.getElementById('coordinates-panel'); // üí° Obt√©m o novo painel
 init();
 animate();

 function init(){
 const container = document.createElement('div');
 document.body.appendChild(container);

 scene = new THREE.Scene();
 camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 20);
 const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
 light.position.set(0.5, 1, 0.25);
 scene.add(light);
 renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
 renderer.setPixelRatio(window.devicePixelRatio);
 renderer.setSize(window.innerWidth, window.innerHeight);
 renderer.xr.enabled = true;
 container.appendChild(renderer.domElement);

 document.body.appendChild(ARButton.createButton(renderer, { requiredFeatures: ['hit-test', 'anchors'] }));
 const geometry = new THREE.RingGeometry(0.06, 0.08, 32).rotateX(-Math.PI/2);
 const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
 reticle = new THREE.Mesh(geometry, material);
 reticle.matrixAutoUpdate = false;
 reticle.visible = false;
 scene.add(reticle);
 controller = renderer.xr.getController(0);
 controller.addEventListener('select', onSelect);
 scene.add(controller);
 window.addEventListener('resize', onWindowResize);
 renderer.xr.addEventListener('sessionstart', onSessionStart);
 renderer.xr.addEventListener('sessionend', onSessionEnd);
 }

 function createTextSprite(text) {
  const canvas = document.createElement('canvas');
  const context = canvas.getContext('2d');
  const fontsize = 50;
  const font = 'bold ' + fontsize + 'px Arial';
  context.font = font;
  context.fillStyle = 'rgba(255, 255, 255, 1.0)';
  context.textAlign = 'center';
  context.textBaseline = 'middle';
  const metrics = context.measureText(text);
  const textWidth = metrics.width;
  const textHeight = fontsize;
  canvas.width = textWidth + 10;
  canvas.height = textHeight + 10;
  context.font = font;
  context.fillStyle = 'rgba(255, 255, 255, 1.0)';
  context.textAlign = 'center';
  context.textBaseline = 'middle';
  context.fillText(text, canvas.width / 2, canvas.height / 2);
  const texture = new THREE.CanvasTexture(canvas);
  const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });
  const sprite = new THREE.Sprite(spriteMaterial);
  sprite.scale.set(0.2, 0.1, 1);
  return sprite;
 }

 function onSessionStart(){
 const session = renderer.xr.getSession();
 session.requestReferenceSpace('viewer').then(function(viewerReferenceSpace){
  session.requestHitTestSource({ space: viewerReferenceSpace }).then(function(source){
  hitTestSource = source;
  });
 });
 session.requestReferenceSpace('local').then(function(refSpace){
  localReferenceSpace = refSpace;
 });
 }

 function onSessionEnd(){
 hitTestSource = null;
 localReferenceSpace = null;
 reticle.visible = false;
 anchoredObjects = [];
 blockCounter = 0;
 distancePanel.innerHTML = '<h3>Dist√¢ncias:</h3>';
 coordinatesPanel.innerHTML = '<h3>Coordenadas Salvas:</h3>'; // üí° Limpa o painel de coordenadas
 }

 function onSelect(){
 if (!reticle.visible || !localReferenceSpace || !hitTestResult) return;
 const session = renderer.xr.getSession();
 session.createAnchor(hitTestResult.transform, localReferenceSpace)
  .then(anchor => {
  blockCounter++;
  const blockName = `bloco${blockCounter}`;
  const boxGeo = new THREE.BoxGeometry(0.12, 0.12, 0.12);
  const boxMat = new THREE.MeshStandardMaterial({ roughness:0.7, metalness:0.0 });
  const box = new THREE.Mesh(boxGeo, boxMat);
  const label = createTextSprite(blockName);
  label.position.y = 0.1;
  box.add(label);
  scene.add(box);
  // üí° Armazenamos o nome do bloco na lista
  anchoredObjects.push({ anchor, box, label, blockName });
  
  updateDistances();
  updateCoordinates(); // üí° Chamada para atualizar as coordenadas
  })
  .catch(error => {
  console.error("Erro ao criar √¢ncora:", error);
  });
 }

 function updateDistances() {
  distancePanel.innerHTML = '<h3>Dist√¢ncias:</h3>';
 
  if (anchoredObjects.length < 2) return;
 
  for (let i = 0; i < anchoredObjects.length; i++) {
   for (let j = i + 1; j < anchoredObjects.length; j++) {
    const block1 = anchoredObjects[i].box;
    const block2 = anchoredObjects[j].box;
    
    const distance = block1.position.distanceTo(block2.position);
    const text = document.createElement('p');
    // üí° Agora usando a propriedade blockName
    text.textContent = `${anchoredObjects[i].blockName} para ${anchoredObjects[j].blockName}: ${distance.toFixed(2)}m`;
    distancePanel.appendChild(text);
   }
  }
 }

 // üí° Fun√ß√£o para exibir as coordenadas
 function updateCoordinates() {
  coordinatesPanel.innerHTML = '<h3>Coordenadas Salvas:</h3>';
  
  anchoredObjects.forEach(obj => {
   const pos = obj.box.position;
   const text = document.createElement('p');
   text.textContent = `${obj.blockName}: x:${pos.x.toFixed(2)}, y:${pos.y.toFixed(2)}, z:${pos.z.toFixed(2)}`;
   coordinatesPanel.appendChild(text);
  });
 }

 function onWindowResize(){
 camera.aspect = window.innerWidth / window.innerHeight;
 camera.updateProjectionMatrix();
 renderer.setSize(window.innerWidth, window.innerHeight);
 }

 function animate(){
 renderer.setAnimationLoop(render);
 }

 function render(timestamp, frame){
 if (frame){
  const referenceSpace = localReferenceSpace;
  if (hitTestSource && referenceSpace){
  const hitTestResults = frame.getHitTestResults(hitTestSource);
  if (hitTestResults.length > 0){
   hitTestResult = hitTestResults[0];
   const pose = hitTestResult.getPose(referenceSpace);
   if (pose) {
   reticle.visible = true;
   reticle.matrix.fromArray(pose.transform.matrix);
   }
  } else {
   reticle.visible = false;
  }
  }
  for (const anchored of anchoredObjects) {
  const anchorPose = frame.getPose(anchored.anchor.anchorSpace, referenceSpace);
  if (anchorPose) {
   anchored.box.matrix.fromArray(anchorPose.transform.matrix);
  }
  }
 }
 renderer.render(scene, camera);
 }
</script>
</body>
</html>