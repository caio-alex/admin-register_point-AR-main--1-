<!DOCTYPE html>
<html lang="pt-BR">
	<head>
		<meta charset="utf-8" />
		<meta
			name="viewport"
			content="width=device-width,initial-scale=1,minimum-scale=1,viewport-fit=cover"
		/>
		<title>WebXR AR Hit Test + QR Marker com fluxo separado</title>
		<script src="https://unpkg.com/jsqr/dist/jsQR.js"></script>
		<style>
			html,
			body {
				height: 100%;
				margin: 0;
				background: #111;
				color: #ddd;
				font-family: Arial;
			}
			#info {
				position: fixed;
				left: 10px;
				top: 10px;
				z-index: 3;
				background: rgba(0, 0, 0, 0.5);
				padding: 10px;
				border-radius: 8px;
				max-width: 320px;
			}
			#pontos {
				position: fixed;
				bottom: 10px;
				left: 10px;
				z-index: 3;
				background: rgba(0, 0, 0, 0.5);
				padding: 10px;
				border-radius: 8px;
				font-size: 12px;
				max-width: 320px;
				white-space: pre-wrap;
			}
			#qr-overlay {
				position: fixed;
				top: 0;
				left: 0;
				width: 100vw;
				height: 100vh;
				background: rgba(0, 0, 0, 0.85);
				display: flex;
				flex-direction: column;
				align-items: center;
				justify-content: center;
				color: white;
				font-size: 18px;
				z-index: 10;
			}
			video {
				width: 320px;
				height: 240px;
				border: 2px solid #0f0;
				border-radius: 10px;
			}
		</style>
	</head>
	<body>
		<div id="qr-overlay">
			<div>Aponte a câmera para o QR Code para calibrar a origem.</div>
			<video id="qr-video" playsinline></video>
			<div style="margin-top: 10px; font-size: 14px; color: #0f0" id="qr-result">
				Aguardando QR code...
			</div>
		</div>

		<div id="info" style="display: none">
			<strong>WebXR AR Hit Test + QR Marker</strong><br />
			Toque no retículo para colocar um cubo.<br />
		</div>

		<div id="pontos">
			<strong>Pontos salvos:</strong><br /><span id="listaPontos"></span>
		</div>

		<script type="module">
			import * as THREE from "https://unpkg.com/three@0.148.0/build/three.module.js";
			import { ARButton } from "https://unpkg.com/three@0.148.0/examples/jsm/webxr/ARButton.js";

			let camera, scene, renderer;
			let controller, reticle;
			let hitTestSource = null;
			let localReferenceSpace = null;

			let marcadorOrigem = null; // posição THREE.Vector3 do marcador QR
			let pontosSalvos = [];

			const qrOverlay = document.getElementById("qr-overlay");
			const qrVideo = document.getElementById("qr-video");
			const qrResult = document.getElementById("qr-result");
			const infoDiv = document.getElementById("info");
			const listaPontosSpan = document.getElementById("listaPontos");

			let videoStream = null;
			let scanning = false;

			async function startQrScanner() {
				try {
					videoStream = await navigator.mediaDevices.getUserMedia({
						video: { facingMode: "environment" },
					});
					qrVideo.srcObject = videoStream;
					await qrVideo.play();
					scanning = true;
					scanLoop();
				} catch (e) {
					qrResult.textContent = "Erro ao acessar a câmera: " + e.message;
				}
			}

			function stopQrScanner() {
				if (videoStream) {
					videoStream.getTracks().forEach((track) => track.stop());
					videoStream = null;
				}
				scanning = false;
			}

			function scanLoop() {
				if (!scanning) return;
				if (qrVideo.readyState === qrVideo.HAVE_ENOUGH_DATA) {
					const canvas = document.createElement("canvas");
					const ctx = canvas.getContext("2d");
					canvas.width = qrVideo.videoWidth;
					canvas.height = qrVideo.videoHeight;
					ctx.drawImage(qrVideo, 0, 0, canvas.width, canvas.height);
					const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
					const code = jsQR(imageData.data, canvas.width, canvas.height);
					if (code) {
						qrResult.textContent = "QR Code detectado: " + code.data;
						marcadorOrigem = new THREE.Vector3(0, 0, 0); // No seu fluxo atual, não temos pose real do QR, só indicamos origem no (0,0,0)
						stopQrScanner();
						showARButton();
						return;
					} else {
						qrResult.textContent = "Aguardando QR code...";
					}
				}
				requestAnimationFrame(scanLoop);
			}

			function showARButton() {
				qrOverlay.style.display = "none";
				infoDiv.style.display = "block";
			}

			initAR();
			animate();
			
			function initAR() {
				const container = document.createElement("div");
				document.body.appendChild(container);

				scene = new THREE.Scene();
				camera = new THREE.PerspectiveCamera(
					70,
					window.innerWidth / window.innerHeight,
					0.01,
					20
				);

				const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
				light.position.set(0.5, 1, 0.25);
				scene.add(light);

				renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.xr.enabled = true;
				container.appendChild(renderer.domElement);

				document.body.appendChild(
					ARButton.createButton(renderer, { requiredFeatures: ["hit-test"] })
				);

				const geometry = new THREE.RingGeometry(0.06, 0.08, 32).rotateX(-Math.PI / 2);
				const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
				reticle = new THREE.Mesh(geometry, material);
				reticle.matrixAutoUpdate = false;
				reticle.visible = false;
				scene.add(reticle);

				controller = renderer.xr.getController(0);
				controller.addEventListener("select", onSelect);
				scene.add(controller);

				window.addEventListener("resize", onWindowResize);

				renderer.xr.addEventListener("sessionstart", onSessionStart);
				renderer.xr.addEventListener("sessionend", onSessionEnd);
			}

			function onSessionStart() {
				const session = renderer.xr.getSession();

				session.requestReferenceSpace("viewer").then((viewerRefSpace) => {
					session.requestHitTestSource({ space: viewerRefSpace }).then((source) => {
						hitTestSource = source;
					});
				});

				session.requestReferenceSpace("local").then((refSpace) => {
					localReferenceSpace = refSpace;
				});
			}

			function onSessionEnd() {
				hitTestSource = null;
				localReferenceSpace = null;
				reticle.visible = false;
				pontosSalvos = [];
				marcadorOrigem = null;
				listaPontosSpan.textContent = "";
			}

			function onSelect() {
				if (!reticle.visible) return;

				const pos = new THREE.Vector3().setFromMatrixPosition(reticle.matrix);

				// Se temos marcador, salvar posição relativa a ele
				let posRelativa = pos.clone();
				if (marcadorOrigem) posRelativa.sub(marcadorOrigem);

				pontosSalvos.push(posRelativa);

				// Mostrar alert com a posição salva (relativa)
				alert(
					`Posição salva:\nX: ${posRelativa.x.toFixed(2)}\nY: ${posRelativa.y.toFixed(
						2
					)}\nZ: ${posRelativa.z.toFixed(2)}`
				);

				const boxGeo = new THREE.BoxGeometry(0.12, 0.12, 0.12);
				const boxMat = new THREE.MeshStandardMaterial({
					roughness: 0.7,
					metalness: 0.0,
				});
				const box = new THREE.Mesh(boxGeo, boxMat);
				box.position.copy(pos);
				scene.add(box);
			}

			function atualizarListaPontos() {
				listaPontosSpan.textContent = pontosSalvos
					.map((p) => `(${p.x.toFixed(2)}, ${p.y.toFixed(2)}, ${p.z.toFixed(2)})`)
					.join("\n");
			}

			function onWindowResize() {
				if (camera) {
					camera.aspect = window.innerWidth / window.innerHeight;
					camera.updateProjectionMatrix();
				}
				if (renderer) {
					renderer.setSize(window.innerWidth, window.innerHeight);
				}
			}

			function animate() {
				renderer.setAnimationLoop(render);
			}

			function render(timestamp, frame) {
				if (frame) {
					const referenceSpace = localReferenceSpace;

					if (hitTestSource && referenceSpace) {
						const hitTestResults = frame.getHitTestResults(hitTestSource);
						if (hitTestResults.length > 0) {
							const hit = hitTestResults[0];
							const pose = hit.getPose(referenceSpace);
							reticle.visible = true;
							reticle.matrix.fromArray(pose.transform.matrix);
						} else {
							reticle.visible = false;
						}
					}
				}
				renderer.render(scene, camera);
			}

			// Começa lendo o QR ao abrir
			startQrScanner();
		</script>
	</body>
</html>