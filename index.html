<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,viewport-fit=cover">
<title>WebXR AR Hit Test ‚Äî Cubo Ancorado</title>
<style>
html,body{height:100%;margin:0;font-family:Arial,Helvetica,sans-serif;background:#111;color:#ddd}
#info{position:fixed;left:10px;top:10px;z-index:2;background:rgba(0,0,0,0.5);padding:10px;border-radius:8px}
canvas{display:block}
</style>
</head>
<body>
<div id="info">
<strong>WebXR AR Hit Test (Com √Çncoras)</strong><br>
Toque no ret√≠culo para colocar um cubo ancorado.
</div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.148.0/build/three.module.js';
import { ARButton } from 'https://unpkg.com/three@0.148.0/examples/jsm/webxr/ARButton.js';

let camera, scene, renderer;
let controller;
let reticle;

// üí° Agora vamos rastrear os objetos ancorados
let anchoredObjects = [];

let hitTestSource = null;
let localReferenceSpace = null;
let hitTestResult = null; // Vamos guardar o √∫ltimo resultado do hit test

init();
animate();

function init(){
const container = document.createElement('div');
document.body.appendChild(container);

scene = new THREE.Scene();

camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 20);

// luz
const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
light.position.set(0.5, 1, 0.25);
scene.add(light);

// renderer
renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.xr.enabled = true;
container.appendChild(renderer.domElement);

// üí° Habilitamos o recurso 'anchors' para usar a API de √¢ncoras
document.body.appendChild(ARButton.createButton(renderer, { requiredFeatures: ['hit-test', 'anchors'] }));

// Reticle
const geometry = new THREE.RingGeometry(0.06, 0.08, 32).rotateX(-Math.PI/2);
const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
reticle = new THREE.Mesh(geometry, material);
reticle.matrixAutoUpdate = false;
reticle.visible = false;
scene.add(reticle);

// Controller para escutar 'select' (toque)
controller = renderer.xr.getController(0);
controller.addEventListener('select', onSelect);
scene.add(controller);

window.addEventListener('resize', onWindowResize);

// Gerenciar start/end da sess√£o
renderer.xr.addEventListener('sessionstart', onSessionStart);
renderer.xr.addEventListener('sessionend', onSessionEnd);
}

function onSessionStart(){
const session = renderer.xr.getSession();

session.requestReferenceSpace('viewer').then(function(viewerReferenceSpace){
session.requestHitTestSource({ space: viewerReferenceSpace }).then(function(source){
hitTestSource = source;
});
});

session.requestReferenceSpace('local').then(function(refSpace){
localReferenceSpace = refSpace;
});
}

function onSessionEnd(){
hitTestSource = null;
localReferenceSpace = null;
reticle.visible = false;
anchoredObjects = [];
}

// üí° Modificamos a fun√ß√£o onSelect para criar a √¢ncora
function onSelect(){
if (!reticle.visible || !localReferenceSpace || !hitTestResult) return;

const session = renderer.xr.getSession();

// Cria a √¢ncora na posi√ß√£o do √∫ltimo hit test
// A promisse retorna a √¢ncora criada
session.createAnchor(hitTestResult.transform, localReferenceSpace)
.then(anchor => {
console.log("√Çncora criada com sucesso!");
// Quando a √¢ncora √© criada, criamos nosso objeto 3D
const boxGeo = new THREE.BoxGeometry(0.12, 0.12, 0.12);
const boxMat = new THREE.MeshStandardMaterial({ roughness:0.7, metalness:0.0 });
const box = new THREE.Mesh(boxGeo, boxMat);
          
// Adicionamos o objeto √† cena
scene.add(box);

// Guardamos a refer√™ncia do objeto e da √¢ncora juntos
anchoredObjects.push({ anchor, box });
})
.catch(error => {
console.error("Erro ao criar √¢ncora:", error);
});
}

function onWindowResize(){
camera.aspect = window.innerWidth / window.innerHeight;
camera.updateProjectionMatrix();
renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate(){
renderer.setAnimationLoop(render);
}

// üí° Modificamos o loop de renderiza√ß√£o para atualizar os cubos com base nas √¢ncoras
function render(timestamp, frame){
if (frame){
const referenceSpace = localReferenceSpace;

if (hitTestSource && referenceSpace){
const hitTestResults = frame.getHitTestResults(hitTestSource);
if (hitTestResults.length > 0){
hitTestResult = hitTestResults[0];
const pose = hitTestResult.getPose(referenceSpace);
if (pose) {
reticle.visible = true;
reticle.matrix.fromArray(pose.transform.matrix);
}
} else {
reticle.visible = false;
}
}

// Atualiza a posi√ß√£o de todos os cubos com base em suas √¢ncoras
for (const anchored of anchoredObjects) {
const anchorPose = frame.getPose(anchored.anchor.anchorSpace, referenceSpace);
if (anchorPose) {
anchored.box.matrix.fromArray(anchorPose.transform.matrix);
}
}
}
renderer.render(scene, camera);
}
</script>
</body>
</html>