<!doctype html>
<html lang="pt-BR">
<head>
 <meta charset="utf-8">
 <meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,viewport-fit=cover">
 <title>WebXR AR Hit Test ‚Äî Cubo Girat√≥rio</title>
 <style>
  html,body{height:100%;margin:0;font-family:Arial,Helvetica,sans-serif;background:#111;color:#ddd}
  #info{position:fixed;left:10px;top:10px;z-index:2;background:rgba(0,0,0,0.5);padding:10px;border-radius:8px}
  canvas{display:block}
    
  /* üí° Novo CSS para o painel de coordenadas */
  #coordinate-list {
   position: fixed;
   left: 10px;
   top: 100px;
   z-index: 2;
   background: rgba(0,0,0,0.5);
   padding: 10px;
   border-radius: 8px;
   max-height: calc(100% - 120px);
   overflow-y: auto;
  }
</style>
</head>
<body>
 <div id="info">
  <strong>WebXR AR Hit Test</strong><br>
  Toque no ret√≠culo para colocar um cubo. Use um dispositivo compat√≠vel (Android + Chrome) e sirva via HTTPS / localhost.
 </div>
 
  <div id="coordinate-list">
  <h3>Posi√ß√µes Salvas:</h3>
 </div>

 <script type="module">
  import * as THREE from 'https://unpkg.com/three@0.148.0/build/three.module.js';
  import { ARButton } from 'https://unpkg.com/three@0.148.0/examples/jsm/webxr/ARButton.js';

  let camera, scene, renderer;
  let controller;
  let reticle;
  let cubes = [];

  let hitTestSource = null;
  let localReferenceSpace = null;

    // üí° Obtenha o novo elemento de lista
    const coordinateList = document.getElementById('coordinate-list');

  init();
  animate();

  function init(){
   const container = document.createElement('div');
   document.body.appendChild(container);

   scene = new THREE.Scene();

   camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 20);

   // luz
   const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
   light.position.set(0.5, 1, 0.25);
   scene.add(light);

   // renderer
   renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
   renderer.setPixelRatio(window.devicePixelRatio);
   renderer.setSize(window.innerWidth, window.innerHeight);
   renderer.xr.enabled = true;
   container.appendChild(renderer.domElement);

   document.body.appendChild(ARButton.createButton(renderer, { requiredFeatures: ['hit-test'] }));

   // Reticle (pequeno anel que marca o ponto de hit)
   const geometry = new THREE.RingGeometry(0.06, 0.08, 32).rotateX(-Math.PI/2);
   const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
   reticle = new THREE.Mesh(geometry, material);
   reticle.matrixAutoUpdate = false;
   reticle.visible = false;
   scene.add(reticle);

   // Controller para escutar 'select' (toque)
   controller = renderer.xr.getController(0);
   controller.addEventListener('select', onSelect);
   scene.add(controller);

   window.addEventListener('resize', onWindowResize);

   // Gerenciar start/end da sess√£o para requisitar o hit test
   renderer.xr.addEventListener('sessionstart', onSessionStart);
   renderer.xr.addEventListener('sessionend', onSessionEnd);
  }

  function onSessionStart(){
   const session = renderer.xr.getSession();

   // pedir reference spaces
   session.requestReferenceSpace('viewer').then(function(viewerReferenceSpace){
    session.requestHitTestSource({ space: viewerReferenceSpace }).then(function(source){
     hitTestSource = source;
    });
   });

   // local para posicionamento das poses obtidas por getPose
   session.requestReferenceSpace('local').then(function(refSpace){
    localReferenceSpace = refSpace;
   });
  }

  function onSessionEnd(){
   hitTestSource = null;
   localReferenceSpace = null;
   reticle.visible = false;
   
   // Limpa a lista de cubos e a exibi√ß√£o
   cubes = [];
   coordinateList.innerHTML = '<h3>Posi√ß√µes Salvas:</h3>';
  }

  function onSelect(){
   if (!reticle.visible) return;

   // Criar um cubo e posicionar de acordo com o reticle
   const boxGeo = new THREE.BoxGeometry(0.12, 0.12, 0.12);
   const boxMat = new THREE.MeshStandardMaterial({ roughness:0.7, metalness:0.0 });
   const box = new THREE.Mesh(boxGeo, boxMat);

   // usar a matrix do reticle (que est√° em localReferenceSpace) para posicionar o cubo
   box.position.setFromMatrixPosition(reticle.matrix);
   scene.add(box);
   
   cubes.push(box); 
   
   // üí° Chamada para atualizar a lista de coordenadas
   updateCoordinateDisplay();
  }
    
    // üí° Fun√ß√£o para exibir as coordenadas salvas
    function updateCoordinateDisplay() {
        // Limpa o conte√∫do do painel antes de adicionar os novos itens
        coordinateList.innerHTML = '<h3>Posi√ß√µes Salvas:</h3>';
        
        cubes.forEach((cube, index) => {
            const pos = cube.position;
            const item = document.createElement('p');
            // Formata as coordenadas para ter apenas 2 casas decimais
            item.textContent = `Cubo ${index + 1}: x:${pos.x.toFixed(2)}, y:${pos.y.toFixed(2)}, z:${pos.z.toFixed(2)}`;
            coordinateList.appendChild(item);
        });
    }

  function onWindowResize(){
   camera.aspect = window.innerWidth / window.innerHeight;
   camera.updateProjectionMatrix();
   renderer.setSize(window.innerWidth, window.innerHeight);
  }

  // loop de render
  function animate(){
   renderer.setAnimationLoop(render);
  }

  function render(timestamp, frame){
   if (frame){
    const referenceSpace = localReferenceSpace;

    if (hitTestSource && referenceSpace){
     const hitTestResults = frame.getHitTestResults(hitTestSource);

     if (hitTestResults.length > 0){
      const hit = hitTestResults[0];
      const pose = hit.getPose(referenceSpace);

      // colocar reticle na pose retornada
      reticle.visible = true;
      reticle.matrix.fromArray(pose.transform.matrix);
     } else {
      reticle.visible = false;
     }
    }
   }

   for (const cube of cubes) {
    cube.rotation.y += 0.02; 
   }

   renderer.render(scene, camera);
  }
 </script>
</body>
</html>